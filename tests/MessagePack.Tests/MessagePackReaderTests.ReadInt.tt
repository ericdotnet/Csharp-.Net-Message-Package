<#@ assembly name="System.Core" #>
<#@ assembly name="System.Numerics" #>
<#@ Import Namespace="System.Linq" #>
<#@ Import Namespace="System.Numerics" #>
// THIS (.cs) FILE IS GENERATED. DO NOT CHANGE IT.
// CHANGE THE .tt FILE INSTEAD.

using System;
using System.Collections.Generic;
using System.Numerics;
using Xunit;

namespace MessagePack.Tests
{
    partial class MessagePackReaderTests
    {
<#
var unsignedTypes = new Type[]
{
    typeof(byte),
    typeof(ushort),
    typeof(uint),
    typeof(ulong),
};
var signedTypes = new Type[]
{
    typeof(sbyte),
    typeof(short),
    typeof(int),
    typeof(long),
};
var allTypes = unsignedTypes.Concat(signedTypes);
BigInteger GetMaxValueAsInt(Type intType) => BigInteger.Parse("0" + GetMaxValue(intType).Substring(2), System.Globalization.NumberStyles.HexNumber);
BigInteger GetMinValueAsInt(Type intType) => BigInteger.Parse(GetMinValue(intType).Substring(2), System.Globalization.NumberStyles.HexNumber);
string GetMaxValue(Type intType) => $"0x{intType.GetField(nameof(int.MaxValue)).GetValue(null):x}";
string GetMinValue(Type intType) => $"0x{intType.GetField(nameof(int.MinValue)).GetValue(null):x}";
#>
        private const sbyte MinNegativeFixInt = unchecked((sbyte)MessagePackCode.MinNegativeFixInt);
        private const sbyte MaxNegativeFixInt = unchecked((sbyte)MessagePackCode.MaxNegativeFixInt);

        private readonly IReadOnlyList<(BigInteger Value, ReadOnlyMemory<byte> Encoded)> IntegersOfInterest = new List<(BigInteger Value, ReadOnlyMemory<byte> Encoded)>
        {
            // * FixInt
            // ** non-boundary
            (3, Encode(b => MessagePackBinary.WriteByte(ref b, 0, 3))),
<# foreach (Type type in allTypes) { #>
            (3, Encode(b => MessagePackBinary.Write<#=type.Name#>Force<#=type.Name#>Block(ref b, 0, 3))),
<# } #>

            (-3, Encode(b => MessagePackBinary.WriteSByte(ref b, 0, -3))),
<# foreach (Type type in signedTypes) { #>
            (-3, Encode(b => MessagePackBinary.Write<#=type.Name#>Force<#=type.Name#>Block(ref b, 0, -3))),
<# } #>

            // ** Boundary conditions
            // *** MaxFixInt
            (MessagePackCode.MaxFixInt, Encode(b => MessagePackBinary.WriteByte(ref b, 0, MessagePackCode.MaxFixInt))),
<# foreach (Type type in allTypes) { #>
            (MessagePackCode.MaxFixInt, Encode(b => MessagePackBinary.Write<#=type.Name#>Force<#=type.Name#>Block(ref b, 0, checked((<#=type.Name#>)MessagePackCode.MaxFixInt)))),
<# } #>
            // *** MinFixInt
            (MessagePackCode.MinFixInt, Encode(b => MessagePackBinary.WriteByte(ref b, 0, MessagePackCode.MinFixInt))),
<# foreach (Type type in allTypes) { #>
            (MessagePackCode.MinFixInt, Encode(b => MessagePackBinary.Write<#=type.Name#>Force<#=type.Name#>Block(ref b, 0, checked((<#=type.Name#>)MessagePackCode.MinFixInt)))),
<# } #>
            // *** MinNegativeFixInt
<# foreach (Type type in signedTypes) { #>
            (MinNegativeFixInt, Encode(b => MessagePackBinary.Write<#=type.Name#>Force<#=type.Name#>Block(ref b, 0, MinNegativeFixInt))),
<# } #>
            // *** MaxNegativeFixInt
<# foreach (Type type in signedTypes) { #>
            (MaxNegativeFixInt, Encode(b => MessagePackBinary.Write<#=type.Name#>Force<#=type.Name#>Block(ref b, 0, MaxNegativeFixInt))),
<# } #>

            (MessagePackCode.MaxFixInt, Encode(b => MessagePackBinary.WriteInt32(ref b, 0, MessagePackCode.MaxFixInt))),
            (MessagePackCode.MinFixInt, Encode(b => MessagePackBinary.WriteInt32(ref b, 0, MessagePackCode.MinFixInt))),
            (MaxNegativeFixInt, Encode(b => MessagePackBinary.WriteInt32(ref b, 0, MaxNegativeFixInt))),
            (MinNegativeFixInt, Encode(b => MessagePackBinary.WriteInt32(ref b, 0, MinNegativeFixInt))),

            // * Encoded as each type of at least 8 bits
            // ** Small positive value
<# foreach (Type t1 in allTypes) { #>
            (3, Encode(b => MessagePackBinary.Write<#=t1.Name#>Force<#=t1.Name#>Block(ref b, 0, 3))),
<# } #>

            // ** Small negative value
<# foreach (Type t1 in signedTypes) { #>
            (-3, Encode(b => MessagePackBinary.Write<#=t1.Name#>Force<#=t1.Name#>Block(ref b, 0, -3))),
<# } #>

            // ** Max values
            // *** Positive
<# foreach (var typeForMaxValue in allTypes) {
    var maxValue = GetMaxValueAsInt(typeForMaxValue);
    foreach (var encodedType in allTypes) {
        if (GetMaxValueAsInt(encodedType) >= maxValue) { #>
            (0x<#=maxValue.ToString("x")#>, Encode(b => MessagePackBinary.Write<#=encodedType.Name#>Force<#=encodedType.Name#>Block(ref b, 0, <#=maxValue#>))),
<#      }
    }
} #>
            // *** Negative
<# foreach (var typeForMinValue in signedTypes) {
    var minValue = GetMinValueAsInt(typeForMinValue);
    foreach (var encodedType in signedTypes) {
        if (GetMinValueAsInt(encodedType) <= minValue) { #>
            (unchecked((<#=typeForMinValue.Name#>)0x<#=minValue.ToString("x")#>), Encode(b => MessagePackBinary.Write<#=encodedType.Name#>Force<#=encodedType.Name#>Block(ref b, 0, <#=minValue#>))),
<#      }
    }
} #>
        };
<# foreach (Type t1 in allTypes) { #>

        [Fact]
        public void Read<#=t1.Name#>_ReadVariousLengthsAndMagnitudes()
        {
            foreach (var (value, encoded) in IntegersOfInterest)
            {
                this.logger.WriteLine("Decoding 0x{0:x} from {1}", value, MessagePackCode.ToFormatName(encoded.Span[0]));
                if (value <= <#=t1.Name#>.MaxValue && value >= <#=t1.Name#>.MinValue)
                {
                    Assert.Equal(value, new MessagePackReader(encoded).Read<#=t1.Name#>());
                }
                else
                {
                    Assert.Throws<OverflowException>(() => new MessagePackReader(encoded).Read<#=t1.Name#>());
                }
            }
        }

        [Fact]
        public void Read<#=t1.Name#>_ThrowsOnUnexpectedCode()
        {
            Assert.Throws<InvalidOperationException>(() => new MessagePackReader(StringEncodedAsFixStr).Read<#=t1.Name#>());
        }
<# } #>
    }
}
